# A0129595N
###### \java\seedu\malitio\commons\events\ui\DeadlinePanelSelectionChangedEvent.java
``` java

/**
 * Represents a selection change in the Deadline List Panel
 */
public class DeadlinePanelSelectionChangedEvent extends BaseEvent{
    private ReadOnlyDeadline newDeadlineSelection;
    
    public DeadlinePanelSelectionChangedEvent(ReadOnlyDeadline newSelection) {
        this.newDeadlineSelection = newSelection;
    }  
    public ReadOnlyDeadline getNewDeadlineSelection() {
        return newDeadlineSelection;
    }    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
 
}
```
###### \java\seedu\malitio\commons\events\ui\EventPanelSelectionChangedEvent.java
``` java
/**
 * Represents a selection change in the Event List Panel
 */
public class EventPanelSelectionChangedEvent extends BaseEvent {
    private ReadOnlyEvent newEventSelection;

    public EventPanelSelectionChangedEvent(ReadOnlyEvent newSelection) {
        this.newEventSelection = newSelection;
    }

    public ReadOnlyEvent getNewEventSelection() {
        return newEventSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\malitio\commons\events\ui\JumpToListRequestEvent.java
``` java
public class JumpToListRequestEvent extends BaseEvent{

    public final int targetIndex;
    public final String typeOfTask;

    public JumpToListRequestEvent(int targetIndex, String typeOfTask) {
        this.targetIndex = targetIndex;
        this.typeOfTask = typeOfTask;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\malitio\commons\events\ui\TaskPanelSelectionChangedEvent.java
``` java
/**
 * Represents a selection change in the FloatingTask List Panel
 */
public class TaskPanelSelectionChangedEvent extends BaseEvent {


    private ReadOnlyFloatingTask newTaskSelection;

    public TaskPanelSelectionChangedEvent(ReadOnlyFloatingTask newSelection) {
        this.newTaskSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ReadOnlyFloatingTask getNewFloatingTaskSelection() {
        return newTaskSelection;
    }

}
```
###### \java\seedu\malitio\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to Malitio.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": adds a task to Malitio. Task name cannot contain \'/\'. \n"
            + "Parameters: NAME [by DEADLINE] [start STARTTIME end ENDTIME] [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " Pay John $100 by Oct 11 2359 t/oweMoney";

    public static final String MESSAGE_SUCCESS = "New task added %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This floating task already exists in Malitio";
    public static final String MESSAGE_DUPLICATE_EVENT = "This event already exists in Malitio";
    public static final String MESSAGE_DUPLICATE_DEADLINE ="This deadline already exists in Malitio";

    private Object toAddTask;

    /**
     * Convenience constructor for floating tasks using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAddTask = new FloatingTask(
                new Name(name),
                new UniqueTagList(tagSet)
        );
    }
    
    /**
     * Convenience constructor for deadlines using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    
    public AddCommand(String name, String date, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAddTask = new Deadline(
                new Name(name),
                new DateTime(date),
                new UniqueTagList(tagSet)
        );
    }
    
    /**
     * Convenience constructor for events using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String start, String end, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        // check if start < end
        this.toAddTask = new Event(
                new Name(name),
                new DateTime(start),
                new DateTime(end),
                new UniqueTagList(tagSet)
        );
    }
    
    /**
     * Executes the command. It will clear the future stack so that no redo can be done after execution.
     */
    @Override
    public CommandResult execute() {
        assert model != null;{
            try {
                model.addTask(toAddTask);
                model.getFuture().clear();
                return new CommandResult(String.format(MESSAGE_SUCCESS, toAddTask));
            } catch (DuplicateFloatingTaskException e) {
                return new CommandResult(MESSAGE_DUPLICATE_TASK);
            } catch (DuplicateDeadlineException e) {
                return new CommandResult(MESSAGE_DUPLICATE_DEADLINE);
            } catch (DuplicateEventException e) {
                return new CommandResult(MESSAGE_DUPLICATE_EVENT);
            }
        }
    }
}
```
###### \java\seedu\malitio\logic\commands\EditCommand.java
``` java
/**
 * Edits a floating task/ deadline/ event identified using it's last displayed index from Malitio.
 * Only the attribute(s) that require changes is(are) entered. 
 */
public class EditCommand extends Command{

    public static final String COMMAND_WORD = "edit";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ":Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be either 'f'/'d'/'e' and a positive integer) [NAME] [by NEWDATE] [START NEWDATE] [END NEWDATE]\n"
            + "Example: " + COMMAND_WORD + " f1 New Name";
    
    public static final String MESSAGE_DUPLICATE_TASK = "The intended edit correspond to a pre-existing floating task in Malitio";
 
    public static final String MESSAGE_DUPLICATE_DEADLINE = "The intended edit correspond to a pre-existing deadline in Malitio";

    public static final String MESSAGE_DUPLICATE_EVENT = "The intended edit correspond to a pre-existing event in Malitio";

    public static final String MESSAGE_INVALID_EVENT = "Event must start before it ends!";
    
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Successfully edited task.\nOld: %1$s\nNew: %2$s";

    public static final String MESSAGE_CHANGING_TASK_TYPE_NOT_SUPPORTED = "Changing of task type not supported. Please do not use key words (by, start, end) in names.";
    
    private final char taskType;
    
    private final int targetIndex;
    
    private Object editedTask;
    
    private Object taskToEdit;
    
    private Name name;
    
    private DateTime due;
    
    private DateTime start;
    
    private DateTime end;
    
    private UniqueTagList tags;
    
    /**
     * Process arguments by extracting out relevant details to change
     */
    public EditCommand(char taskType, int targetIndex, String name, String due, String start, String end, Set<String> newTags) 
            throws IllegalValueException {
        assert validArgTask(taskType, name, due, start, end, newTags) ;
        this.taskType = taskType;
        this.targetIndex = targetIndex;
        if (!name.equals("")) {
            this.name = new Name(name);
        }
        if (!due.equals("")) {
            this.due = new DateTime(due);
        }
        if (!start.equals("")) {
            this.start = new DateTime(start);
        }
        if (!end.equals("")) {
            this.end = new DateTime(end);
        }
        this.tags = processTags(newTags);
    }
    
    /**
     * Executes the command. It will clear the future stack so that no redo can be done after execution.
     */
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList lastShownList;
        lastShownList = getCorrectList();        
        if (lastShownList.size() < targetIndex || targetIndex <= 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        if (!checkCorrectParameters()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_CHANGING_TASK_TYPE_NOT_SUPPORTED);
        }

        taskToEdit = lastShownList.get(targetIndex - 1);
                
        try {
            assert model != null;
            fillInTheGaps(taskToEdit);
            constructEditedTask();
            model.editTask(editedTask, taskToEdit);
            model.getFuture().clear();
        } catch (UniqueFloatingTaskList.DuplicateFloatingTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (UniqueDeadlineList.DuplicateDeadlineException e) {
            return new CommandResult(MESSAGE_DUPLICATE_DEADLINE);
        } catch (DuplicateEventException e) {
            return new CommandResult(MESSAGE_DUPLICATE_EVENT);
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_EVENT);
        } catch (FloatingTaskNotFoundException | DeadlineNotFoundException | EventNotFoundException e) {
            assert false : "not possible";
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit, editedTask));
    }

    private boolean checkCorrectParameters() {
        if ((taskType == 'f' && due == null && start == null && end == null)) {
            return true;
        } else if ((taskType == 'd' && start == null && end == null)) {
            return true;
        } else if ((taskType == 'e' && due == null)) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Creates the correct edited task object
     * @throws IllegalValueException
     */
    private void constructEditedTask() throws IllegalValueException {
        if (taskType == 'f') {
            editedTask = new FloatingTask(name, tags);
        } else if (taskType == 'd') {
            editedTask = new Deadline(name, due, tags);
        } else {
            editedTask = new Event(name, start, end, tags);
        }
    }

    /**
     * @return UnmodifiableObservableList of the correct task type
     */
    private UnmodifiableObservableList getCorrectList() {
        UnmodifiableObservableList lastShownList;
        if (taskType == 'f') {
        lastShownList = model.getFilteredFloatingTaskList();
        } else if (taskType == 'd') {
        lastShownList = model.getFilteredDeadlineList(); 
        } else {
        lastShownList = model.getFilteredEventList();
        }
        return lastShownList;
    }
    
    
    /**
     * fillInTheGaps will replace the task's attributes not entered by the user by extracting from the task to be edited .
     * @param ReadOnly<TaskType>
     */
    private void fillInTheGaps(Object taskToEdit) {
        if (isFloatingTask(taskToEdit)) {
            getFloatingTaskDetails(taskToEdit);
        } else if (isDeadline(taskToEdit)) {
            getDeadlineDetails(taskToEdit);
        } else {
            getEventDetails(taskToEdit);
        }
    }
    
    /**
     * Method to check for valid (at least one non-empty) arguments for the corresponding task type
     */
    private boolean validArgTask(char taskType, String name, String due, String start, String end,
            Set<String> newTags) {
        if (taskType == 'f') {
            return (!name.equals("") || !newTags.isEmpty()) && start.equals("") && end.equals("") && due.equals("");
        } else if (taskType == 'd') {
            return (!name.equals("") || !due.equals("") || !newTags.isEmpty()) && start.equals("")
                    && end.equals("");
        } else {
            return (!name.equals("") || !start.equals("") || !end.equals("") || !newTags.isEmpty())
                    && due.equals("");
        }
    }
    
    private boolean isDeadline(Object taskToEdit) {
        return taskToEdit instanceof ReadOnlyDeadline;
    }

    private boolean isFloatingTask(Object taskToEdit) {
        return taskToEdit instanceof ReadOnlyFloatingTask;
    }
    
    /**
     * processTags return a UniqueTagList of tags or returns null if no tags were entered.
     * @param newTags
     * @return UniqueTagList or Null
     * @throws IllegalValueException
     */
    private UniqueTagList processTags(Set<String> newTags) throws IllegalValueException {
        if (!newTags.isEmpty() && newTags.toArray()[0].equals("null") && newTags.size()==1) {
            return new UniqueTagList();
        } 
        else if (!newTags.isEmpty()){
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : newTags) {
            tagSet.add(new Tag(tagName));
            }
            return new UniqueTagList(tagSet);
        }       
        else {
            return null;
        }
    }

    /**
     * Replace the editedTask, type casted to Event, details if they are empty 
     * @param taskToEdit
     */
    private void getEventDetails(Object taskToEdit) {
        if (this.name == null) {
            this.name = ((Event) taskToEdit).getName();
        }
        if (this.start == null) {
            this.start = ((Event) taskToEdit).getStart();
        }
        if (this.end == null) {
            this.end = ((Event) taskToEdit).getEnd();
        }
        if (this.tags == null) {
            this.tags = ((Event) taskToEdit).getTags();
        }
    }

    /**
     * Replace the editedTask, type casted to Deadline, details if they are empty
     * @param taskToEdit
     */
    private void getDeadlineDetails(Object taskToEdit) {
        if (this.name == null) {
            this.name = ((ReadOnlyDeadline) taskToEdit).getName();
        }
        if (this.due == null) {
            this.due = ((ReadOnlyDeadline) taskToEdit).getDue();
        }
        if (this.tags == null) {
            this.tags = ((ReadOnlyDeadline) taskToEdit).getTags();
        }
    }

    /**
     * Replace the editedTask, type casted to Floating Task, details if they are empty
     * @param taskToEdit
     */
    private void getFloatingTaskDetails(Object taskToEdit) {
        if (this.name == null) {
            this.name = ((ReadOnlyFloatingTask) taskToEdit).getName();
        }
        if (this.tags == null) {
            this.tags = ((ReadOnlyFloatingTask) taskToEdit).getTags();
        }
    }
    
}
```
###### \java\seedu\malitio\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_REDO_ADD_SUCCESS = "Redo successful. Redo add %1$s";
    public static final String MESSAGE_REDO_DELETE_SUCCESS = "Redo Successful. Redo delete %1$s";
    public static final String MESSAGE_REDO_CLEAR_SUCCESS = "Redo clear successful";
    public static final String MESSAGE_REDO_EDIT_SUCCESS = "Redo successful. Redo edit from \n%1$s to \n%2$s";
    public static final String MESSAGE_REDO_MARK_SUCCESS = "Redo mark sucessful";
    public static final String MESSAGE_REDO_UNMARK_SUCCESS = "Redo unmark sucessful";
    public static final String MESSAGE_REDO_COMPLETE_SUCCESS = "Redo complete successful";
    public static final String MESSAGE_REDO_UNCOMPLETE_SUCCESS = "Redo uncomplete successful";
    public String result;

    @Override
    public CommandResult execute() {

        Stack<InputHistory> future = model.getFuture();
        if (future.isEmpty()) {
            return new CommandResult("No action to redo!");
        }
        InputHistory previous = future.pop();

        switch (previous.getUndoCommand()) {

        case AddCommand.COMMAND_WORD:
            result = executeAdd((InputDeleteHistory) previous);
            return new CommandResult(result);

        case DeleteCommand.COMMAND_WORD:
            result = executeDelete((InputAddHistory) previous);
            return new CommandResult(result);

        case EditCommand.COMMAND_WORD:
            result = executeEdit((InputEditHistory) previous);
            return new CommandResult(result);

        case ClearCommand.COMMAND_WORD:
            result = executeClear((InputClearHistory) previous);
            return new CommandResult(result);

        case UnmarkCommand.COMMAND_WORD:
            result = executeUnmark((InputMarkHistory) previous);
            return new CommandResult(result);

        case MarkCommand.COMMAND_WORD:
            result = executeMark((InputUnmarkHistory) previous);
            return new CommandResult(result);

        case UncompleteCommand.COMMAND_WORD:
            result = executeUncomplete((InputCompleteHistory) previous);
            return new CommandResult(result);

        case CompleteCommand.COMMAND_WORD:
            result = executeComplete((InputUncompleteHistory) previous);
            return new CommandResult(result);

        default:
            assert false;
            return null;
        }
    }
    
    //========== Private helper methods ==================================================
    
    public String executeAdd(InputDeleteHistory previous) {
        try {
            if (isFloatingTask(previous)) {
                model.addFloatingTaskAtSpecificPlace(previous.getTask(), previous.getPositionOfFloatingTask());
            } else {
                model.addTask(previous.getTask());
            }
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return String.format(MESSAGE_REDO_ADD_SUCCESS, previous.getTask().toString());
    }

    public String executeDelete(InputAddHistory previous) {
        try {
            model.deleteTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return String.format(MESSAGE_REDO_DELETE_SUCCESS, previous.getTask().toString());
    }

    private String executeEdit(InputEditHistory previous) {
        try {
            model.editTask(previous.getEditedTask(), previous.getTaskToEdit());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return String.format(MESSAGE_REDO_EDIT_SUCCESS, previous.getTaskToEdit().toString(), previous.getEditedTask().toString());
    }
    
    private String executeClear(InputClearHistory previous) {
        ReadOnlyMalitio previousModel = new Malitio(previous.getFloatingTask(), previous.getDeadline(),
                previous.getEvent(), previous.getTag());
        model.resetData(previousModel);
        return MESSAGE_REDO_CLEAR_SUCCESS;
    }
    
    private String executeUnmark(InputMarkHistory previous) {
        try {
            model.unmarkTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_REDO_UNMARK_SUCCESS;
    }
    
    private String executeMark(InputUnmarkHistory previous) {
        try {
            model.markTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_REDO_MARK_SUCCESS;
    }
    
    private String executeUncomplete(InputCompleteHistory previous) {
        try {
            model.uncompleteTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_REDO_UNCOMPLETE_SUCCESS;
    }

    private String executeComplete(InputUncompleteHistory previous) {
        try {
            model.completeTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_REDO_COMPLETE_SUCCESS;
    }
    
    /**
     * Method to check if the task is a floating task
     */
    private boolean isFloatingTask(InputDeleteHistory previous) {
        return previous.getPositionOfFloatingTask() != -1;
    }
}
```
###### \java\seedu\malitio\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_UNDO_ADD_SUCCESS = "Undo successful. Undo add %1$s";
    public static final String MESSAGE_UNDO_DELETE_SUCCESS = "Undo Successful. Undo delete %1$s";
    public static final String MESSAGE_UNDO_CLEAR_SUCCESS = "Undo clear successful";
    public static final String MESSAGE_UNDO_EDIT_SUCCESS = "Undo successful. Undo edit from \n%1$s to \n%2$s";
    public static final String MESSAGE_UNDO_MARK_SUCCESS = "Undo mark sucessful";
    public static final String MESSAGE_UNDO_UNMARK_SUCCESS = "Undo unmark sucessful";
    public static final String MESSAGE_UNDO_COMPLETE_SUCCESS = "Undo complete successful";
    public static final String MESSAGE_UNDO_UNCOMPLETE_SUCCESS = "Undo uncomplete successful";
    public String result;

    @Override
    public CommandResult execute() {

        Stack<InputHistory> history = model.getHistory();
        if (history.isEmpty()) {
            return new CommandResult("No action to undo!");
        }
        InputHistory previous = history.pop();
        switch (previous.getUndoCommand()) {

        case AddCommand.COMMAND_WORD:
            result = executeAdd((InputDeleteHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case DeleteCommand.COMMAND_WORD:
            result = executeDelete((InputAddHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case EditCommand.COMMAND_WORD:
            result = executeEdit((InputEditHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case ClearCommand.COMMAND_WORD:
            result = executeClear((InputClearHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case UnmarkCommand.COMMAND_WORD:
            result = executeUnmark((InputMarkHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case MarkCommand.COMMAND_WORD:
            result = executeMark((InputUnmarkHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case UncompleteCommand.COMMAND_WORD:
            result = executeUncomplete((InputCompleteHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        case CompleteCommand.COMMAND_WORD:
            result = executeComplete((InputUncompleteHistory) previous);
            updateModel(history);
            return new CommandResult(result);

        default:
            assert false;
            return null;
        }
    }

    //========== Private helper methods ==================================================
    
    public String executeAdd(InputDeleteHistory previous) {
        try {
            if (previous.getPositionOfFloatingTask() != -1) {
                model.addFloatingTaskAtSpecificPlace(previous.getTask(), previous.getPositionOfFloatingTask());
            } else {
                model.addTask(previous.getTask());
            }
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return String.format(MESSAGE_UNDO_DELETE_SUCCESS, previous.getTask().toString());
    }

    public String executeDelete(InputAddHistory previous) {        
        try {
            model.deleteTask(previous.getTask());  
        } catch (Exception e) {
            assert false : "Not Possible";
        }
        return String.format(MESSAGE_UNDO_ADD_SUCCESS, previous.getTask().toString());
    }
    
    private String executeEdit(InputEditHistory previous) {
        try {
            model.editTask(previous.getEditedTask(), previous.getTaskToEdit());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return String.format(MESSAGE_UNDO_EDIT_SUCCESS, previous.getTaskToEdit().toString(),
                previous.getEditedTask().toString());
    }
    
    private String executeClear(InputClearHistory previous) {
        ReadOnlyMalitio previousModel = new Malitio(previous.getFloatingTask(), previous.getDeadline(), previous.getEvent(), previous.getTag());
        model.resetData(previousModel);
        return MESSAGE_UNDO_CLEAR_SUCCESS;
    }
    
    private String executeUnmark(InputMarkHistory previous) {
        try {
            model.unmarkTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_UNDO_MARK_SUCCESS;
    }
    
    private String executeMark(InputUnmarkHistory previous) {
        try {
            model.markTask(previous.getTask());
        } catch (Exception e) {
        assert false : "Not possible";
        }
        return MESSAGE_UNDO_UNMARK_SUCCESS;
    }
    
    private String executeUncomplete(InputCompleteHistory previous) {
       try {
           model.uncompleteTask(previous.getTask());
       } catch (Exception e) {
           assert false : "Not possible";
       }
       return MESSAGE_UNDO_COMPLETE_SUCCESS;
    }
    
    private String executeComplete(InputUncompleteHistory previous) {
        try {
            model.completeTask(previous.getTask());
        } catch (Exception e) {
            assert false : "Not possible";
        }
        return MESSAGE_UNDO_UNCOMPLETE_SUCCESS;
    }

    private void updateModel(Stack<InputHistory> history) {
        showAllListsInModel();
        updateRedoStack(history);
    }
    
    private void showAllListsInModel() {
        model.updateFilteredTaskListToShowAll();
        model.updateFilteredDeadlineListToShowAll();
        model.updateFilteredEventListToShowAll();
    }
    
    /**
     * Updates the redo stack with InputHistory of the action undone.
     * @param history
     */
    private void updateRedoStack(Stack<InputHistory> history) {
        model.getFuture().push(history.pop());
    }

}
```
###### \java\seedu\malitio\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the edit task command.
     * 
     * @param arguments
     * @return the prepared command
     */
    private Command prepareEdit(String args) {
        final Matcher matcher = EDIT_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        try {
            String index = parseIndex(matcher.group("targetIndex"));
            if (index.isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
            char taskType = index.charAt(0);
            int taskNum = Integer.parseInt(index.substring(1));
            String name = matcher.group("name");
            if (name.equals("") && getTagsFromArgs(matcher.group("tagArguments")).isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
            String deadline = getDeadlineFromArgs(name);
            if (!deadline.isEmpty()) {
                name = name.replaceAll(" by " + deadline, "");
            }

            String start = getStartFromArgs(name);
            if (!start.isEmpty()) {
                name = name.replaceAll(" start " + start, "");
            }

            String end = getEndFromArgs(name);
            if (!end.isEmpty()) {
                name = name.replaceAll(" end " + end, "");
            }
            name = name.trim();
                return new EditCommand(
                        taskType,
                        taskNum,
                        name,
                        deadline,
                        start,
                        end,
                        getTagsFromArgs(matcher.group("tagArguments"))
                        );

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
```
###### \java\seedu\malitio\model\history\InputAddHistory.java
``` java
public class InputAddHistory extends InputHistory {
    
    private Object task;
    
    public InputAddHistory(Object target) {
        this.task = target;
        this.commandForUndo = DeleteCommand.COMMAND_WORD;
    }
        
    public Object getTask() {
        return task;
    }

}
```
###### \java\seedu\malitio\model\history\InputClearHistory.java
``` java
public class InputClearHistory extends InputHistory{
    
    UniqueFloatingTaskList originalFloatingTaskList = new UniqueFloatingTaskList();
    UniqueDeadlineList originalDeadlineList = new UniqueDeadlineList();
    UniqueEventList originalEventList = new UniqueEventList();
    UniqueTagList originalTagList = new UniqueTagList();

    public InputClearHistory(UniqueFloatingTaskList task, UniqueDeadlineList deadline,
            UniqueEventList event, UniqueTagList tag) {
        this.originalFloatingTaskList.getInternalList().addAll(task.getInternalList());
        this.originalDeadlineList.getInternalList().addAll(deadline.getInternalList());
        this.originalEventList.getInternalList().addAll(event.getInternalList());
        this.originalTagList.getInternalList().addAll(tag.getInternalList());
        this.commandForUndo = ClearCommand.COMMAND_WORD;
    }
    
    public UniqueFloatingTaskList getFloatingTask() {
        return originalFloatingTaskList;
    }

    public UniqueDeadlineList getDeadline() {
        return originalDeadlineList;
    }
    
    public UniqueEventList getEvent() {
        return originalEventList;
    }
    
    public UniqueTagList getTag() {
        return originalTagList;
    }
}
```
###### \java\seedu\malitio\model\history\InputCompleteHistory.java
``` java
public class InputCompleteHistory extends InputHistory {
    
    Object taskToUncomplete;
    
    public InputCompleteHistory(Object taskToUncomplete) {
        this.taskToUncomplete = taskToUncomplete;
        this.commandForUndo = UncompleteCommand.COMMAND_WORD;
    }
    
    public Object getTask() {
        return taskToUncomplete;
    }
}
```
###### \java\seedu\malitio\model\history\InputDeleteHistory.java
``` java
public class InputDeleteHistory extends InputHistory {
    private Object task;
    private int initialPositionOfFloatingTask = -1;

    /**
     * Constructor for the InputDeleteHistory for deletion of floating task.
     * Will change the variable initialPositionOfFloatingTask to ensure that undo-ing a delete
     * command will insert the floating task back to its original index.
     * 
     * @param target
     *            task to be deleted
     * @param observableList
     *            list of floating task from the model to extract the position
     *            of the floating task in the list before it is deleted
     */
    public InputDeleteHistory(Object target, ObservableList<FloatingTask> observableList) {
        this.commandForUndo = AddCommand.COMMAND_WORD;
        String name = ((ReadOnlyFloatingTask) target).getName().fullName;
        UniqueTagList tags = ((ReadOnlyFloatingTask) target).getTags();
        this.initialPositionOfFloatingTask = observableList.indexOf(target);
        this.task = new FloatingTask(new Name(name), new UniqueTagList(tags));
    }

    /**
     * Constructor for the InputDeleteHistory for deletion of deadline or event.
     * Will not change the variable initialPositionOfFloatingTask
     * 
     * @param target
     *            deadline/event to be deleted
     */
    public InputDeleteHistory(Object target) {
        String name, due, start, end;
        UniqueTagList tags;
        this.commandForUndo = AddCommand.COMMAND_WORD;
        try {
            if (isDeadline(target)) {
                name = ((Deadline) target).getName().fullName;
                due = ((Deadline) target).getDue().toString();
                tags = ((Deadline) target).getTags();
                this.task = new Deadline(new Name(name), new DateTime(due), new UniqueTagList(tags));
            } else {
                name = ((Event) target).getName().fullName;
                start = ((Event) target).getStart().toString();
                end = ((Event) target).getEnd().toString();
                tags = ((Event) target).getTags();
                this.task = new Event(new Name(name), new DateTime(start), new DateTime(end), new UniqueTagList(tags));
            }
        } catch (Exception e) {
            assert false : "Not possible";
        }
    }

    private boolean isDeadline(Object target) {
        return target instanceof ReadOnlyDeadline;
    }

    public Object getTask() {
        return task;
    }

    /**
     * @return -1 if the task is a deadline/event or a non-negative number if task is a floating task
     */
    public int getPositionOfFloatingTask() {
        return initialPositionOfFloatingTask;
    }
}
```
###### \java\seedu\malitio\model\history\InputEditHistory.java
``` java
public class InputEditHistory extends InputHistory {

    private Object taskToEdit;

    private Object editedTask;
    
    public InputEditHistory(Object edited, Object beforeEdit) {
        this.commandForUndo = EditCommand.COMMAND_WORD;
        this.taskToEdit = edited;
        if (isFloatingTask(edited)) {
            createEditedFloatingTask(beforeEdit);
        } else if (isDeadline(edited)) {
            createEditedDeadline(beforeEdit);
        } else {
            createEditedEvent(beforeEdit);
        }
    }


    private void createEditedEvent(Object beforeEdit) {
        String name = ((Event)beforeEdit).getName().fullName;
        String start = ((Event)beforeEdit).getStart().toString();
        String end = ((Event)beforeEdit).getEnd().toString();
        UniqueTagList tags = ((Event)beforeEdit).getTags();
        try {
            this.editedTask = new Event(new Name(name), new DateTime(start), new DateTime(end), tags);
        } catch (IllegalValueException e) {
            assert false: "not possible";
        }
    }


    private void createEditedDeadline(Object beforeEdit) {
        String name = ((ReadOnlyDeadline) beforeEdit).getName().fullName;
        String due = ((ReadOnlyDeadline) beforeEdit).getDue().toString();
        UniqueTagList tags = ((ReadOnlyDeadline) beforeEdit).getTags();
        try {
            this.editedTask = new Deadline(new Name(name), new DateTime(due), tags);
        } catch (IllegalValueException e) {
            assert false : "not possible";
        }
    }


    private void createEditedFloatingTask(Object beforeEdit) {
        String name = ((ReadOnlyFloatingTask) beforeEdit).getName().fullName;
        UniqueTagList tags = ((ReadOnlyFloatingTask) beforeEdit).getTags();
        this.editedTask = new FloatingTask(new Name(name), tags);
    }
        
    
    private boolean isDeadline(Object edited) {
        return edited instanceof Deadline;
    }

    private boolean isFloatingTask(Object edited) {
        return edited instanceof FloatingTask;
    }
    
    public Object getTaskToEdit() {
        return taskToEdit;
    }
    
    public Object getEditedTask() {
        return editedTask;
    }    
}
```
###### \java\seedu\malitio\model\history\InputHistory.java
``` java
public abstract class InputHistory {
    
    protected String commandForUndo;
    
    public String getUndoCommand() {
        return commandForUndo;
    }
}
```
###### \java\seedu\malitio\model\history\InputMarkHistory.java
``` java
public class InputMarkHistory extends InputHistory {

    Object taskToMark;

    public InputMarkHistory(Object taskToMark) {
        this.commandForUndo = UnmarkCommand.COMMAND_WORD;
        this.taskToMark = taskToMark;
    }

    public Object getTask() {
        return taskToMark;
    }
}
```
###### \java\seedu\malitio\model\history\InputUncompleteHistory.java
``` java
public class InputUncompleteHistory extends InputHistory {

    Object taskToComplete;
    
    public InputUncompleteHistory(Object taskToComplete) {
        this.taskToComplete = taskToComplete;
        this.commandForUndo = CompleteCommand.COMMAND_WORD;
    }
    
    public Object getTask() {
        return taskToComplete;
    }
}
```
###### \java\seedu\malitio\model\history\InputUnmarkHistory.java
``` java
public class InputUnmarkHistory extends InputHistory {
    
    Object taskToUnmark;

    public InputUnmarkHistory(Object taskToUnmark) {
        this.commandForUndo = MarkCommand.COMMAND_WORD;
        this.taskToUnmark = taskToUnmark;
    }

    public Object getTask() {
        return taskToUnmark;
    }
}
```
###### \java\seedu\malitio\model\Malitio.java
``` java
    /**
     * Adds a task to Malitio. Also checks the new task's tags and updates
     * {@link #tags} with any new tags found, and updates the Tag objects in the
     * task to point to those in {@link #tags}.
     *
     * @throws UniqueFloatingTaskList.DuplicateFloatingTaskException
     *             if an equivalent task already exists.
     * @throws DuplicateDeadlineException
     * @throws DuplicateEventException
     */
    public void addTask(Object p)
            throws DuplicateFloatingTaskException, DuplicateDeadlineException, DuplicateEventException {
        addToCorrectList(p);
        syncTagsWithMasterList(p);
    }

    /**
     * Checks for the type of the p and adds to the correct list in Malitio.
     * 
     * @param p
     *            task which can be FloatingTask, Deadline or Event
     * @throws DuplicateFloatingTaskException
     * @throws DuplicateDeadlineException
     * @throws DuplicateEventException
     */
    private void addToCorrectList(Object p)
            throws DuplicateFloatingTaskException, DuplicateDeadlineException, DuplicateEventException {
        if (isFloatingTask(p)) {
            tasks.add((FloatingTask) p);
        } else if (isDeadline(p)) {
            deadlines.add((Deadline) p);
            deadlines.sort();
        } else {
            events.add((Event) p);
            events.sort();
        }
    }

    public void addTask(Object p, int index) throws UniqueFloatingTaskList.DuplicateFloatingTaskException {
        syncTagsWithMasterList(p);
        tasks.add((FloatingTask) p, index);
    }

    /**
     * Ensures that every tag in this task: - exists in the master list
     * {@link #tags} - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Object task) {
        final UniqueTagList taskTags = getTagsListFromTask(task);
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        setTagsToTask(task, commonTagReferences);
    }

    private boolean isFloatingTask(Object p) {
        return p instanceof FloatingTask || p instanceof ReadOnlyFloatingTask;
    }

    private boolean isDeadline(Object p) {
        return p instanceof Deadline || p instanceof ReadOnlyDeadline;
    }

    /**
     * Check for the correct task type and set tags to it.
     * 
     * @param task
     *            task can be either FloatingTask, Deadline or Event
     * @param commonTagReferences
     *            set of tags to be added to the task
     */
    private void setTagsToTask(Object task, final Set<Tag> commonTagReferences) {
        if (isFloatingTask(task)) {
            ((FloatingTask) task).setTags(new UniqueTagList(commonTagReferences));
        } else if (isDeadline(task)) {
            ((Deadline) task).setTags(new UniqueTagList(commonTagReferences));
        } else {
            ((Event) task).setTags(new UniqueTagList(commonTagReferences));
        }
    }

    /**
     * Check for the correct task type and get tag list from it.
     * 
     * @param task
     *            task can be either FloatingTask, Deadline or Event
     * @return UniqueTagList of the task
     */
    private UniqueTagList getTagsListFromTask(Object task) {
        UniqueTagList taskTags;
        if (isFloatingTask(task)) {
            taskTags = ((FloatingTask) task).getTags();
        } else if (isDeadline(task)) {
            taskTags = ((Deadline) task).getTags();
        } else {
            taskTags = ((Event) task).getTags();
        }
        return taskTags;
    }

    public boolean removeTask(Object key)
            throws FloatingTaskNotFoundException, DeadlineNotFoundException, EventNotFoundException {
        if (isFloatingTask(key)) {
            return removeFloatingTask(key);
        } else if (isDeadline(key)) {
            return removeDeadline(key);
        } else {
            return removeEvent(key);
        }
    }

    private boolean removeEvent(Object key) throws EventNotFoundException {
        if (events.remove((ReadOnlyEvent) key)) {
            return true;
        } else {
            throw new EventNotFoundException();
        }
    }

    private boolean removeDeadline(Object key) throws DeadlineNotFoundException {
        if (deadlines.remove((ReadOnlyDeadline) key)) {
            return true;
        } else {
            throw new DeadlineNotFoundException();
        }
    }

    private boolean removeFloatingTask(Object key) throws FloatingTaskNotFoundException {
        if (tasks.remove((ReadOnlyFloatingTask) key)) {
            return true;
        } else {
            throw new FloatingTaskNotFoundException();
        }
    }

    public void editTask(Object edited, Object beforeEdit)
            throws FloatingTaskNotFoundException, DuplicateFloatingTaskException, DuplicateDeadlineException,
            DeadlineNotFoundException, DuplicateEventException, EventNotFoundException {
        syncTagsWithMasterList(edited);
        editTaskAccordingToTaskType(edited, beforeEdit);
    }

    /**
     * Checks for the task type of the edited and beforeEdit objects and assign
     * the editing accordingly.
     * 
     * @param edited
     *            the edited task
     * @param beforeEdit
     *            the task to be edited
     * @throws DuplicateFloatingTaskException
     * @throws FloatingTaskNotFoundException
     * @throws DuplicateDeadlineException
     * @throws DeadlineNotFoundException
     * @throws DuplicateEventException
     * @throws EventNotFoundException
     */
    private void editTaskAccordingToTaskType(Object edited, Object beforeEdit)
            throws DuplicateFloatingTaskException, FloatingTaskNotFoundException, DuplicateDeadlineException,
            DeadlineNotFoundException, DuplicateEventException, EventNotFoundException {
        if (edited instanceof FloatingTask && beforeEdit instanceof ReadOnlyFloatingTask) {
            tasks.edit((FloatingTask) edited, (ReadOnlyFloatingTask) beforeEdit);
        } else if (edited instanceof Deadline && beforeEdit instanceof ReadOnlyDeadline) {
            deadlines.edit((Deadline) edited, (ReadOnlyDeadline) beforeEdit);
            deadlines.sort();
        } else {
            events.edit((Event) edited, (Event) beforeEdit);
            events.sort();
        }
    }
    
```
###### \java\seedu\malitio\model\ModelManager.java
``` java

    @Override
    public void addTask(Object task)
            throws DuplicateFloatingTaskException, DuplicateDeadlineException, DuplicateEventException {
        malitio.addTask(task);
        history.add(new InputAddHistory(task));
        updateAllListToShowAll();
        indicateMalitioChanged();
        indicateTaskListChanged(task);
    }

    @Override
    public void addFloatingTaskAtSpecificPlace(Object task, int index) throws DuplicateFloatingTaskException {
        malitio.addTask(task, index);
        history.add(new InputAddHistory(task));
        updateFilteredTaskListToShowAll();
        indicateMalitioChanged();
        indicateTaskListChanged(task);
    }

    @Override
    public void editTask(Object edited, Object beforeEdit) throws FloatingTaskNotFoundException, DuplicateFloatingTaskException, DuplicateDeadlineException,
    DeadlineNotFoundException, DuplicateEventException, EventNotFoundException {
        malitio.editTask(edited, beforeEdit);
        history.add(new InputEditHistory(edited, beforeEdit));
        updateAllListToShowAll();
        indicateMalitioChanged();
        indicateTaskListChanged(edited);
    }
    
```
###### \java\seedu\malitio\model\ModelManager.java
``` java
    /**
     * This method will post an event to indicate that a task has been added/modified.
     * @param task the task which an action has been performed on it i.e. add/edit/mark/unmark/complete/uncomplete
     */
    private void indicateTaskListChanged(Object task) {
        String taskType;
        int positionOfTask;
        if (isFloatingTask(task)) {
            taskType = "floating task";
            positionOfTask = filteredFloatingTasks.indexOf(task);
        } else if (isDeadline(task)) {
            taskType = "deadline";
            positionOfTask = filteredDeadlines.indexOf(task);
        } else {
            taskType = "event";
            positionOfTask =filteredEvents.indexOf(task);
        }
        raise(new JumpToListRequestEvent(positionOfTask, taskType));
    }

    private boolean isFloatingTask(Object task) {
        return task instanceof FloatingTask;
    }
    
    private boolean isDeadline(Object task) {
        return task instanceof Deadline;
    }
    
```
###### \java\seedu\malitio\model\task\UniqueDeadlineList.java
``` java
    /**
     * Returns true if the list contains an equivalent deadline as the given
     * argument as well as identical tag(s).
     */
    public boolean containsWithTags(ReadOnlyDeadline toCheck) {
        assert toCheck != null;
        if (!internalList.contains(toCheck)) {
            return false;
        } else {
            int index = internalList.indexOf(toCheck);
            if (toCheck.getTags().getInternalList().isEmpty()) {
                return internalList.get(index).getTags().getInternalList().isEmpty();
            } else {
                return internalList.get(index).getTags().getInternalList()
                        .containsAll(toCheck.getTags().getInternalList());
            }
        }
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateDeadlineException
     *             if the task to add is a duplicate of an existing task in the
     *             list.
     */
    public void add(Deadline toAdd) throws DuplicateDeadlineException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateDeadlineException();
        }
        internalList.add(toAdd);
    }

    /**
     * Edits the specified deadline by deleting and re-adding of the edited
     * (changed) deadline
     * 
     * @param edited
     *            the edited deadline
     * @param beforeEdit
     *            the original deadline
     * @throws DuplicateDeadlineException
     * @throws DeadlineNotFoundException
     */
    public void edit(Deadline edited, ReadOnlyDeadline beforeEdit)
            throws DuplicateDeadlineException, DeadlineNotFoundException {
        assert edited != null;
        assert beforeEdit != null;
        if (containsWithTags(edited)) {
            throw new DuplicateDeadlineException();
        }

        if (!contains(beforeEdit)) {
            throw new DeadlineNotFoundException();
        }

        internalList.remove(beforeEdit);
        internalList.add(edited);
    }

```
###### \java\seedu\malitio\model\task\UniqueEventList.java
``` java
    /**
     * Returns true if the list contains an equivalent event as the given
     * argument as well as identical tag(s).
     */
    public boolean containsWithTags(ReadOnlyEvent toCheck) {
        assert toCheck != null;
        if (!internalList.contains(toCheck)) {
            return false;
        } else {
            int index = internalList.indexOf(toCheck);
            if (toCheck.getTags().getInternalList().isEmpty()) {
                return internalList.get(index).getTags().getInternalList().isEmpty();
            } else {
                return internalList.get(index).getTags().getInternalList()
                        .containsAll(toCheck.getTags().getInternalList());
            }
        }
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateEventException
     *             if the event to add is a duplicate of an existing event in
     *             the list.
     */
    public void add(Event toAdd) throws DuplicateEventException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateEventException();
        }
        internalList.add(toAdd);
    }

    /**
     * Edits the specified event by deleting and re-adding of the edited
     * (changed) event.
     * 
     * @param edited
     *            the edited event
     * @param beforeEdit
     *            the original event
     * @throws DuplicateEventException
     * @throws EventNotFoundException
     */
    public void edit(Event edited, ReadOnlyEvent beforeEdit) throws DuplicateEventException, EventNotFoundException {
        assert edited != null;
        assert beforeEdit != null;
        if (containsWithTags(edited)) {
            throw new DuplicateEventException();
        }

        if (!contains(beforeEdit)) {
            throw new EventNotFoundException();
        }

        internalList.remove(beforeEdit);
        internalList.add(edited);
    }
```
###### \java\seedu\malitio\model\task\UniqueFloatingTaskList.java
``` java
    /**
     * Returns true if the list contains an equivalent task as the given
     * argument as well as identical tag(s).
     */
    public boolean containsWithTags(ReadOnlyFloatingTask toCheck) {
        assert toCheck != null;
        if (!internalList.contains(toCheck)) {
            return false;
        } else {
            int index = internalList.indexOf(toCheck);
            if (toCheck.getTags().getInternalList().isEmpty()) {
                return internalList.get(index).getTags().getInternalList().isEmpty();
            } else {
                return internalList.get(index).getTags().getInternalList()
                        .containsAll(toCheck.getTags().getInternalList());
            }
        }
    }

    /**
     * Adds a floating task to the list.
     * 
     * @throws DuplicateFloatingTaskException
     *             if the task to add is a duplicate of an existing task in the
     *             list.
     */
    public void add(FloatingTask toAdd) throws DuplicateFloatingTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateFloatingTaskException();
        }
        internalList.add(toAdd);
    }

    /**
     * Adds a floating task to the list at the given index
     * 
     * @param toAdd
     * @param index
     * @throws DuplicateFloatingTaskException
     *             if the task to add is a duplicate of an existing task in the
     *             list.
     */
    public void add(FloatingTask toAdd, int index) throws DuplicateFloatingTaskException {
        assert toAdd != null;
        assert index >= 0;
        if (contains(toAdd)) {
            throw new DuplicateFloatingTaskException();
        }
        internalList.add(index, toAdd);
    }

    /**
     * Edits the specified floating task by deleting and re-adding of the edited
     * (changed) floating task
     * 
     * @param edited
     *            the edited floating task
     * @param beforeEdit
     *            the original floating task
     * @throws DuplicateFloatingTaskException
     * @throws FloatingTaskNotFoundException
     */
    public void edit(FloatingTask edited, ReadOnlyFloatingTask beforeEdit)
            throws DuplicateFloatingTaskException, FloatingTaskNotFoundException {
        assert edited != null;
        assert beforeEdit != null;
        if (containsWithTags(edited)) {
            throw new DuplicateFloatingTaskException();
        }

        if (!contains(beforeEdit)) {
            throw new FloatingTaskNotFoundException();
        }

        int indexToReplace = internalList.indexOf(beforeEdit);
        internalList.remove(beforeEdit);
        internalList.add(indexToReplace, edited);
    }
    
```
###### \java\seedu\malitio\ui\UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadTaskDetail(event.getNewFloatingTaskSelection());
        mainWindow.getEventListPanel().getEventListView().getSelectionModel().clearSelection();
        mainWindow.getDeadlineListPanel().getDeadlineListView().getSelectionModel().clearSelection();
    }
    
    @Subscribe
    private void handleDeadlinePanelSelectionChangedEvent(DeadlinePanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadTaskDetail(event.getNewDeadlineSelection());
        mainWindow.getEventListPanel().getEventListView().getSelectionModel().clearSelection();
        mainWindow.getTaskListPanel().getTaskListView().getSelectionModel().clearSelection();
    }
    
    @Subscribe
    private void handleEventPanelSelectionChangedEvent(EventPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadTaskDetail(event.getNewEventSelection());
        mainWindow.getTaskListPanel().getTaskListView().getSelectionModel().clearSelection();
        mainWindow.getDeadlineListPanel().getDeadlineListView().getSelectionModel().clearSelection();
    }

    @Subscribe
    private void handleJumpToTaskListRequestEvent(JumpToListRequestEvent event) {
        String taskType = event.typeOfTask;
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (taskType.equals("floating task")) {
            mainWindow.getTaskListPanel().scrollTo(event.targetIndex);
        } else if (taskType.equals("deadline")) {
            mainWindow.getDeadlineListPanel().scrollTo(event.targetIndex);
        } else {
            mainWindow.getEventListPanel().scrollTo(event.targetIndex);
        }
    }
}
```
